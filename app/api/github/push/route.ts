import { NextRequest, NextResponse } from 'next/server'
import { auth, clerkClient } from '@clerk/nextjs/server'
import { generateProjectScaffold, ProjectConfig } from '@/lib/scaffold'

// =============================================================================
// GITHUB PUSH - Create repo and push code with proper scaffold
// =============================================================================

interface PushRequest {
  repoName: string
  code: string
  pages?: { name: string; path: string; code: string; sectionId?: string }[]
  isPrivate?: boolean
  description?: string
  projectConfig?: {
    name?: string
    brand?: {
      primaryColor?: string
      secondaryColor?: string
      font?: string
      headingFont?: string
      mode?: 'dark' | 'light'
    }
    seo?: {
      title?: string
      description?: string
    }
  }
}

export async function POST(req: NextRequest) {
  const { userId } = await auth()
  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  // Get GitHub token from Clerk
  const client = await clerkClient()
  const user = await client.users.getUser(userId)
  const githubData = user.privateMetadata?.github as { accessToken?: string; username?: string } | undefined

  if (!githubData?.accessToken) {
    return NextResponse.json({ 
      error: 'GitHub not connected',
      requiresAuth: true 
    }, { status: 401 })
  }

  const { repoName, code, pages, isPrivate = false, description, projectConfig } = await req.json() as PushRequest

  if (!repoName || (!code && (!pages || pages.length === 0))) {
    return NextResponse.json({ error: 'Missing repoName or code' }, { status: 400 })
  }

  // Sanitize repo name
  const sanitizedName = repoName
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 100)

  const headers = {
    'Authorization': `Bearer ${githubData.accessToken}`,
    'Accept': 'application/vnd.github.v3+json',
    'Content-Type': 'application/json',
  }

  try {
    // 1. Create repository
    const createRepoResponse = await fetch('https://api.github.com/user/repos', {
      method: 'POST',
      headers,
      body: JSON.stringify({
        name: sanitizedName,
        description: description || `Generated by HatchIt - ${new Date().toLocaleDateString()}`,
        private: isPrivate,
        auto_init: false,
      }),
    })

    let repo = await createRepoResponse.json()

    // If repo exists, use it
    if (createRepoResponse.status === 422 && repo.errors?.[0]?.message?.includes('already exists')) {
      const existingRepoResponse = await fetch(`https://api.github.com/repos/${githubData.username}/${sanitizedName}`, {
        headers,
      })
      if (!existingRepoResponse.ok) {
        return NextResponse.json({ error: 'Could not access existing repo' }, { status: 400 })
      }
      repo = await existingRepoResponse.json()
    } else if (!createRepoResponse.ok) {
      console.error('GitHub create repo error:', repo)
      return NextResponse.json({ error: repo.message || 'Failed to create repo' }, { status: 400 })
    }

    // 2. Build file tree using proper scaffold
    const files = buildProjectFiles(code, pages, sanitizedName, projectConfig)

    // 3. Create all files using Git Data API (allows creating multiple files in one commit)
    // First, create blobs for all files
    const blobs = await Promise.all(
      files.map(async (file) => {
        const blobResponse = await fetch(`https://api.github.com/repos/${repo.full_name}/git/blobs`, {
          method: 'POST',
          headers,
          body: JSON.stringify({
            content: file.content,
            encoding: 'utf-8',
          }),
        })
        const blob = await blobResponse.json()
        return { path: file.path, sha: blob.sha, mode: '100644', type: 'blob' }
      })
    )

    // Create a tree with all files
    const treeResponse = await fetch(`https://api.github.com/repos/${repo.full_name}/git/trees`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        tree: blobs,
      }),
    })
    const tree = await treeResponse.json()

    // Create a commit
    const commitResponse = await fetch(`https://api.github.com/repos/${repo.full_name}/git/commits`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        message: pages && pages.length > 0 
          ? `Initial commit - ${pages.length} pages from HatchIt`
          : 'Initial commit from HatchIt',
        tree: tree.sha,
      }),
    })
    const commit = await commitResponse.json()

    // Update main branch to point to new commit
    await fetch(`https://api.github.com/repos/${repo.full_name}/git/refs/heads/main`, {
      method: 'PATCH',
      headers,
      body: JSON.stringify({ sha: commit.sha }),
    }).catch(async () => {
      // If main doesn't exist, create it
      await fetch(`https://api.github.com/repos/${repo.full_name}/git/refs`, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          ref: 'refs/heads/main',
          sha: commit.sha,
        }),
      })
    })

    return NextResponse.json({
      success: true,
      repoUrl: repo.html_url,
      repoName: repo.full_name,
      vercelImportUrl: `https://vercel.com/new/import?s=${encodeURIComponent(repo.html_url)}`,
    })

  } catch (error) {
    console.error('GitHub push error:', error)
    return NextResponse.json({ error: 'Failed to push to GitHub' }, { status: 500 })
  }
}

function buildProjectFiles(
  code: string, 
  pages?: { name: string; path: string; code: string; sectionId?: string }[],
  repoName?: string,
  projectConfig?: PushRequest['projectConfig']
) {
  const files: { path: string; content: string }[] = []
  
  // Generate proper scaffold from project config
  const scaffoldConfig: ProjectConfig = {
    name: projectConfig?.name || repoName || 'My HatchIt Site',
    slug: repoName || 'hatchit-site',
    description: projectConfig?.seo?.description || 'Built with HatchIt.dev',
    brand: {
      primaryColor: projectConfig?.brand?.primaryColor || '#10b981',
      secondaryColor: projectConfig?.brand?.secondaryColor || '#059669',
      font: projectConfig?.brand?.font || 'Inter',
      headingFont: projectConfig?.brand?.headingFont || projectConfig?.brand?.font || 'Inter',
      mode: projectConfig?.brand?.mode || 'dark',
    },
    seo: {
      title: projectConfig?.seo?.title || projectConfig?.name || 'My HatchIt Site',
      description: projectConfig?.seo?.description || 'Built with HatchIt.dev',
    },
  }

  // Generate scaffold files (but skip page files - we'll add actual content)
  const scaffoldFiles = generateProjectScaffold(scaffoldConfig)
  
  for (const file of scaffoldFiles) {
    // Skip page files - we'll add those with actual generated content
    if (!file.path.endsWith('page.tsx')) {
      files.push({ path: file.path, content: file.content })
    }
  }

  // Helper: Extract Lucide icon names from code
  const extractLucideIcons = (codeStr: string): string[] => {
    const lucideIconRegex = /<([A-Z][a-zA-Z0-9]*)\s/g
    const icons = new Set<string>()
    let match
    while ((match = lucideIconRegex.exec(codeStr)) !== null) {
      const name = match[1]
      if (!['AnimatePresence', 'Component', 'Fragment', 'Suspense'].includes(name)) {
        icons.add(name)
      }
    }
    return Array.from(icons)
  }

  // Add pages with generated content
  if (pages && pages.length > 0) {
    const sectionComponents: Record<string, string> = {}
    
    pages.forEach((page) => {
      const icons = extractLucideIcons(page.code)
      const lucideImport = icons.length > 0 ? `import { ${icons.join(', ')} } from 'lucide-react'` : ''
      
      // Save sections as individual component files
      if (page.sectionId) {
        const componentName = page.sectionId.charAt(0).toUpperCase() + page.sectionId.slice(1).replace(/-/g, '')
        sectionComponents[page.sectionId] = componentName
        
        files.push({
          path: `components/sections/${componentName}.tsx`,
          content: `'use client'
import { useState, useEffect, useMemo, useCallback, useRef } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
${lucideImport}

${page.code}
`
        })
      }
      
      // Create page file
      const pageCode = `'use client'
import { useState, useEffect, useMemo, useCallback, useRef } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
${lucideImport}

${page.code}`

      const pagePath = page.path === '/' ? 'app/page.tsx' : `app${page.path}/page.tsx`
      files.push({ path: pagePath, content: pageCode })
    })
    
    // Update sections index
    if (Object.keys(sectionComponents).length > 0) {
      // Find and update the sections index file
      const indexFileIndex = files.findIndex(f => f.path === 'components/sections/index.ts')
      if (indexFileIndex >= 0) {
        files[indexFileIndex] = {
          path: 'components/sections/index.ts',
          content: `// Section components - generated by HatchIt builder
export { default as Header } from '../Header'
export { default as Footer } from '../Footer'

// Generated sections:
${Object.entries(sectionComponents).map(([, name]) => 
  `export { default as ${name} } from './${name}'`
).join('\n')}
`
        }
      }
    }
  } else if (code) {
    // Single component
    const icons = extractLucideIcons(code)
    const lucideImport = icons.length > 0 ? `import { ${icons.join(', ')} } from 'lucide-react'` : ''
    
    files.push({
      path: 'app/page.tsx',
      content: `'use client'
import { useState, useEffect, useMemo, useCallback, useRef } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
${lucideImport}
import Component from '@/components/Generated'

export default function Home() {
  return <Component />
}`
    })
    
    files.push({
      path: 'components/Generated.tsx',
      content: `'use client'
import { useState, useEffect, useMemo, useCallback, useRef } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
${lucideImport}

${code}`
    })
  }

  return files
}
