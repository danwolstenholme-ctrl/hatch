import { NextRequest, NextResponse } from 'next/server'
import { auth, clerkClient, currentUser } from '@clerk/nextjs/server'
import { getProjectById, getSectionById, updateSectionRefinement, getSectionsByProjectId } from '@/lib/db'
import { LIMITS } from '@/types/subscriptions'

// =============================================================================
// THE REFINER - Claude Opus 4.5 with Extended Thinking
// Handles:
// 1. Code refinement (polish, fix, user-directed changes)
// 2. Conversational help (design partner, ideation, troubleshooting)
// =============================================================================

// Use centralized limits from types/subscriptions.ts
const FREE_TOTAL_CREDITS = parseInt(process.env.FREE_TOTAL_CREDITS || String(LIMITS.GUEST_TOTAL_CREDITS), 10)
const ARCHITECT_REFINEMENT_LIMIT = LIMITS.ARCHITECT_REFINEMENTS_MONTHLY

// System prompt for conversational help (when no code is being modified)
const HELP_SYSTEM_PROMPT = `You are a senior design partner embedded inside HatchIt, an AI website builder. You're not a support bot - you're a creative collaborator who thinks deeply and offers real insights.

The user is actively building a website. You can see what section they're working on and sometimes their current code.

## YOUR ROLE

You're here to have a real conversation about their build. Think out loud. Offer opinions. Push back when something could be better. Celebrate when they nail it.

## HOW TO HELP

**Design Ideation:**
- "That hero feels a bit generic. What if you went bolder - maybe a full-bleed gradient with oversized typography?"
- "I love the dark theme. Consider adding some subtle glow effects to make it feel premium."

**Prompt Crafting:**
- Help them write better prompts: "Try: 'Minimal nav with glass morphism, logo left, 3 links right, sticky on scroll'"
- Explain WHY certain prompt details matter

**Troubleshooting:**
- Preview not showing → "Still generating - wait for the green checkmark"
- Layout issues → Suggest specific refinements they can type
- Confused about features → Guide them through the UI

**Real Talk:**
- Don't just agree with everything. If their idea could be better, say so constructively.
- Share your reasoning. "I think X because Y."
- Ask clarifying questions to understand their vision.

## PERSONALITY

- Thoughtful, not rushed
- Opinionated but collaborative
- Direct and helpful, not sycophantic
- Talk like a colleague, not a manual

## DON'T

- Don't give generic tutorials
- Don't suggest leaving HatchIt or editing files manually
- Don't provide code blocks for them to copy-paste
- Don't be overly formal or robotic

Keep responses conversational. A few sentences is usually enough.`

const REFINER_SYSTEM_PROMPT = `You are "The Architect" in Refinement Mode.
Your task is to polish React + Tailwind code generated by the Genesis Engine.
You are surgical, precise, and aesthetic-obsessed.

## WHAT TO FIX

1. **Accessibility**
   - Missing alt text on images → add descriptive alt
   - Missing ARIA labels on buttons/links → add aria-label
   - Missing focus states → add focus:ring-2 focus:ring-emerald-500
   - Non-semantic HTML → change div to nav, section, article, etc.
   - Poor heading hierarchy → fix h1/h2/h3 order

2. **Performance**
   - Animations not using transform/opacity → convert to GPU-accelerated
   - Inline functions in JSX → note but don't refactor (minimal changes)

3. **Code Quality**
   - Missing key props in .map() → add unique keys
   - Inconsistent Tailwind class order → organize: layout, spacing, sizing, colors, effects
   - Hardcoded colors → use Tailwind scale (zinc-500 not #71717a)

4. **Interactive States**
   - Buttons missing hover → add hover:bg-*, hover:scale-*
   - Links missing hover → add hover:text-*, hover:underline
   - Missing transitions → add transition-all duration-200

5. **Visual Analysis (The Retina)**
   - If a screenshot is provided, analyze it for layout issues, contrast problems, or visual bugs.
   - Fix alignment issues visible in the render.
   - Ensure text contrast meets accessibility standards.

## WHAT NOT TO DO

❌ Add new features or content
❌ Change the design intent or layout
❌ Remove or add sections
❌ Rewrite the component from scratch
❌ Add imports or exports
❌ Change the component function name
❌ Add comments to the code

## OUTPUT FORMAT

Return ONLY valid JSON (no markdown code blocks, no explanation):

{
  "refinedCode": "function ComponentName() { return ( <section>...</section> ) }",
  "changes": ["Added alt text to logo image", "Added focus:ring to CTA button", "Fixed missing key in features map"]
}

If code is already good:

{
  "refinedCode": "the original code unchanged",
  "changes": []
}

Be surgical. Minimal changes. Maximum impact.`

// User-directed refinement prompt - when user asks for specific changes
const USER_REFINE_SYSTEM_PROMPT = `You are a precise code modifier. The user has already generated React + Tailwind code and wants specific changes.

## YOUR TASK

Apply the user's requested changes to the code. Be precise and surgical.

## RULES

1. **Apply exactly what the user asks** - no more, no less
2. **Preserve the original structure** - don't rewrite or reorganize unless asked
3. **Keep the code valid** - ensure it still works after changes
4. **Maintain the style** - keep consistent with existing Tailwind patterns

## OUTPUT FORMAT

Return ONLY valid JSON (no markdown code blocks, no explanation):

{
  "refinedCode": "function ComponentName() { return ( <section>...</section> ) }",
  "changes": ["Made buttons larger with py-4 px-8", "Changed primary color to emerald-500"]
}
`

export async function POST(request: NextRequest) {
  try {
    // Parse body early to check for mode
    const body = await request.json()
    const { 
      sectionId, projectId, code, sectionType, sectionName, userPrompt, refineRequest, screenshot,
      // Conversational help mode fields
      message, conversationHistory, currentCode, projectName
    } = body

    // CONVERSATIONAL HELP MODE - no code refinement, just answering questions
    const isHelpMode = message && !code && !refineRequest
    
    if (isHelpMode) {
      if (!process.env.ANTHROPIC_API_KEY) {
        return NextResponse.json({ error: 'API not configured' }, { status: 500 })
      }

      // Build context for help
      const context = []
      if (projectName) context.push(`Project: ${projectName}`)
      if (sectionType || sectionName) context.push(`Current section: ${sectionName || sectionType}`)
      if (currentCode) context.push(`Current code preview:\n\`\`\`tsx\n${currentCode.slice(0, 1500)}\n\`\`\``)

      const systemWithContext = HELP_SYSTEM_PROMPT + (context.length > 0 ? `\n\nContext:\n${context.join('\n')}` : '')

      // Build messages for conversation
      const messages = [
        ...(conversationHistory || []).map((msg: { role: string; content: string }) => ({
          role: msg.role,
          content: msg.content
        })),
        { role: 'user', content: message }
      ]

      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': process.env.ANTHROPIC_API_KEY,
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: 'claude-opus-4-5-20251101',
          max_tokens: 16000,
          thinking: {
            type: 'enabled',
            budget_tokens: 10000
          },
          system: systemWithContext,
          messages
        })
      })

      if (!response.ok) {
        const error = await response.text()
        console.error('Refiner help API error:', error)
        return NextResponse.json({ error: 'AI service error' }, { status: 500 })
      }

      const data = await response.json()
      // With extended thinking, find the text block
      const textBlock = data.content.find((block: { type: string }) => block.type === 'text')
      const assistantResponse = textBlock?.text || 'Sorry, I could not generate a response.'

      return NextResponse.json({ response: assistantResponse })
    }

    // CODE REFINEMENT MODE - original behavior
    // Guest/Demo mode bypass - projectId starting with 'demo-' skips auth
    const isDemoMode = projectId && typeof projectId === 'string' && projectId.startsWith('demo-')

    const { userId } = await auth()
    
    // Only require auth for non-demo requests
    if (!isDemoMode && !userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Self-healing check: If the request is to fix a runtime error, it's free.
    // "FIX RUNTIME ERROR" is the prefix used in SectionBuilder.tsx
    const isSelfHealing = refineRequest && refineRequest.startsWith('FIX RUNTIME ERROR')

    // Skip usage checks for demo mode
    if (!isDemoMode) {
      // Check user tier and Architect usage limits
      const client = await clerkClient()
      const user = await client.users.getUser(userId!)
      const accountSub = user.publicMetadata?.accountSubscription as { 
        status?: string
        tier?: 'architect' | 'visionary' | 'singularity'
      } | undefined
      
      const freeCreditsUsed = (user.publicMetadata?.freeCreditsUsed as number) || 0
      const hasActiveSub = accountSub?.status === 'active'
      const architectUsed = (user.publicMetadata?.architectRefinementsUsed as number) || 0

      // Free users: allow up to FREE_REFINE_LIMIT (1), then block
      const FREE_REFINE_LIMIT = 1
      
      if (!isSelfHealing && !hasActiveSub && architectUsed >= FREE_REFINE_LIMIT) {
        return NextResponse.json({
          error: 'Free refinement limit reached. Upgrade to Architect for unlimited polish.',
          limitReached: true,
          used: architectUsed,
          limit: FREE_REFINE_LIMIT,
        }, { status: 429 })
      }

      // Check Architect usage for paid tiers (Singularity is unlimited)
      // Skip check if self-healing
      if (!isSelfHealing && hasActiveSub && accountSub?.tier && accountSub.tier !== 'singularity') {
        const resetDate = user.publicMetadata?.architectRefinementsResetDate as string | undefined
        const today = new Date().toISOString().split('T')[0]
        
        // Check if we need to reset (new month or past reset date)
        const shouldReset = !resetDate || new Date(resetDate) <= new Date(today)
        const currentUsage = shouldReset ? 0 : architectUsed
        
        const limit = accountSub.tier === 'architect'
          ? ARCHITECT_REFINEMENT_LIMIT
          : parseInt(process.env.PRO_ARCHITECT_MONTHLY_LIMIT || '30', 10)

        if (currentUsage >= limit) {
          return NextResponse.json({ 
            error: `Monthly refinement limit reached (${limit}/month). ${accountSub?.tier === 'architect' ? 'Upgrade to Visionary for 30/month.' : 'Upgrade to Singularity for unlimited.'}`,
            limitReached: true,
            used: currentUsage,
            limit: limit
          }, { status: 429 })
        }
      }

      const clerkUser = await currentUser()

      // Verify code is provided
      if (!code) {
        return NextResponse.json(
          { error: 'Missing required field: code' },
          { status: 400 }
        )
      }

      // Verify ownership: section -> project -> user (using clerk_id)
      let section = await getSectionById(sectionId)
      
      // Fallback: Try to find by projectId + sectionType if sectionId lookup failed
      if (!section && projectId && sectionType) {
        const projectSections = await getSectionsByProjectId(projectId)
        section = projectSections.find(s => s.section_id === sectionType) || null
      }

      console.log('[Refine] Found section:', section ? section.id : 'null')
      if (!section) {
        return NextResponse.json({ error: `Section not found for ID: ${sectionId}` }, { status: 404 })
      }
      const project = await getProjectById(section.project_id)
      if (!project) {
        return NextResponse.json({ error: 'Project not found' }, { status: 404 })
      }
      if (project.user_id !== userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 403 })
      }
    } else {
      // Demo mode - just verify code is provided
      if (!code) {
        return NextResponse.json(
          { error: 'Missing required field: code' },
          { status: 400 }
        )
      }
    }

    // Determine if this is a user-directed refinement or auto-polish
    const isUserDirected = !!refineRequest
    
    // Build the appropriate prompt
    const userMessage = isUserDirected
      ? `Section: ${sectionName || sectionType || 'Unknown'}

CURRENT CODE:
${code}

USER'S REFINEMENT REQUEST:
"${refineRequest}"

Apply these specific changes to the code.`
      : `Section: ${sectionName || sectionType || 'Unknown'}
User's original request: "${userPrompt || 'Not provided'}"

Refine this code:

${code}`

    // Prepare messages for Claude
    const messages: any[] = [
      { role: 'user', content: [] }
    ]

    // Add text content
    messages[0].content.push({
      type: 'text',
      text: userMessage
    })

    // Add visual context if screenshot is provided (The Retina)
    if (screenshot) {
      // Remove data URL prefix if present to get raw base64
      const base64Data = screenshot.replace(/^data:image\/\w+;base64,/, "")
      
      messages[0].content.push({
        type: 'text',
        text: "I have attached a screenshot of the currently rendered component. Use this visual data to identify layout issues, contrast problems, or visual bugs that might not be obvious in the code alone. If the visual output contradicts the code's intent, prioritize fixing the code to match the visual goal."
      })
      
      messages[0].content.push({
        type: 'image',
        source: {
          type: 'base64',
          media_type: 'image/png',
          data: base64Data
        }
      })
    }

    // Call Claude Opus 4.5 with extended thinking for better refinement
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': process.env.ANTHROPIC_API_KEY || '',
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-opus-4-5-20251101',
        max_tokens: 16000,
        thinking: {
          type: 'enabled',
          budget_tokens: 10000
        },
        system: isUserDirected ? USER_REFINE_SYSTEM_PROMPT : REFINER_SYSTEM_PROMPT,
        messages: messages
      })
    })

    if (!response.ok) {
      const error = await response.json()
      console.error('Anthropic API error:', error)
      return NextResponse.json({ error: 'Refinement failed' }, { status: 500 })
    }

    const data = await response.json()
    // With extended thinking, response has thinking block + text block
    // Find the text block (skip thinking blocks)
    const textBlock = data.content.find((block: { type: string }) => block.type === 'text')
    const responseText = textBlock?.text || ''
    console.log('[refine-section] Raw response:', responseText.slice(0, 500))

    // Parse JSON response
    let refinedCode = code
    let changes: string[] = []
    let wasRefined = false

    try {
      const cleanedResponse = responseText
        .replace(/^```(?:json)?\n?/gm, '')
        .replace(/\n?```$/gm, '')
        .trim()

      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/)
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0])
        refinedCode = parsed.refinedCode || code
        changes = parsed.changes || []
        wasRefined = changes.length > 0
      }
    } catch (parseError) {
      console.error('[refine-section] Failed to parse response:', parseError)
      
      // Fallback: Extract code block directly
      if (!wasRefined) {
         const codeMatch = responseText.match(/```(?:tsx|jsx|javascript|typescript)?\n([\s\S]*?)```/)
         if (codeMatch) {
            refinedCode = codeMatch[1]
            changes = ["Extracted code from raw output"]
            wasRefined = true
         }
      }
    }

    // Increment Refinement usage for paid tiers after successful refinement
    // Skip if self-healing (free) or demo mode
    if (!isDemoMode && !isSelfHealing && wasRefined && userId) {
      try {
        const client = await clerkClient()
        const user = await client.users.getUser(userId)
        const accountSub = user.publicMetadata?.accountSubscription as { 
          status?: string
          tier?: 'architect' | 'visionary' | 'singularity'
        } | undefined
        const hasActiveSub = accountSub?.status === 'active'
        const freeCreditsUsed = (user.publicMetadata?.freeCreditsUsed as number) || 0
        
        if (hasActiveSub && accountSub?.tier && accountSub.tier !== 'singularity') {
          const currentUsed = (user.publicMetadata?.architectRefinementsUsed as number) || 0
          const resetDate = user.publicMetadata?.architectRefinementsResetDate as string | undefined
          const today = new Date()
          
          // Calculate next month's reset date if needed
          let newResetDate = resetDate
          if (!resetDate || new Date(resetDate) <= today) {
            // Set reset to first of next month
            const nextMonth = new Date(today.getFullYear(), today.getMonth() + 1, 1)
            newResetDate = nextMonth.toISOString().split('T')[0]
          }
          
          const shouldReset = !resetDate || new Date(resetDate) <= today
          const newUsed = shouldReset ? 1 : currentUsed + 1
          
          await client.users.updateUser(userId, {
            publicMetadata: {
              ...user.publicMetadata,
              architectRefinementsUsed: newUsed,
              architectRefinementsResetDate: newResetDate,
            }
          })
        }

        // Track free credit usage for non-paid users
        if (!hasActiveSub) {
          await client.users.updateUser(userId, {
            publicMetadata: {
              ...user.publicMetadata,
              freeCreditsUsed: freeCreditsUsed + 1,
            },
          })
        }
      } catch (updateError) {
        console.error('[refine-section] Failed to update usage:', updateError)
        // Don't fail the request, just log
      }
    }

    // SAVE TO DATABASE - persist the refined code (skip for demo mode)
    if (wasRefined && !isDemoMode && sectionId) {
      await updateSectionRefinement(sectionId, true, refinedCode, changes)
    }

    return NextResponse.json({
      refined: wasRefined,
      code: refinedCode,
      changes,
      model: 'claude-opus-4-5-20251101',
    })

  } catch (error) {
    console.error('Error refining section:', error)
    return NextResponse.json({ error: 'Failed to refine section' }, { status: 500 })
  }
}
