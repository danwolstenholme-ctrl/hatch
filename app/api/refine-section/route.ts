import { NextRequest, NextResponse } from 'next/server'
import { auth, clerkClient } from '@clerk/nextjs/server'
import Anthropic from '@anthropic-ai/sdk'
import { PRO_OPUS_MONTHLY_LIMIT, AccountSubscription } from '@/types/subscriptions'

// =============================================================================
// OPUS 4.5 - THE REFINER
// Auto-polishes code after Sonnet builds
// Fixes issues WITHOUT adding features
// Pro tier: 30 refinements/month (configurable), Agency tier: unlimited
// =============================================================================

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
})

const REFINER_SYSTEM_PROMPT = `You are a surgical code refiner. Your ONLY job is to polish React + Tailwind code.

You receive code generated by Sonnet. Your task is to FIX issues, not add features.

## WHAT TO FIX

1. **Accessibility**
   - Missing alt text on images → add descriptive alt
   - Missing ARIA labels on buttons/links → add aria-label
   - Missing focus states → add focus:ring-2 focus:ring-cyan-500
   - Non-semantic HTML → change div to nav, section, article, etc.
   - Poor heading hierarchy → fix h1/h2/h3 order

2. **Performance**
   - Animations not using transform/opacity → convert to GPU-accelerated
   - Inline functions in JSX → note but don't refactor (minimal changes)

3. **Code Quality**
   - Missing key props in .map() → add unique keys
   - Inconsistent Tailwind class order → organize: layout, spacing, sizing, colors, effects
   - Hardcoded colors → use Tailwind scale (zinc-500 not #71717a)

4. **Interactive States**
   - Buttons missing hover → add hover:bg-*, hover:scale-*
   - Links missing hover → add hover:text-*, hover:underline
   - Missing transitions → add transition-all duration-200

## WHAT NOT TO DO

❌ Add new features or content
❌ Change the design intent or layout
❌ Remove or add sections
❌ Rewrite the component from scratch
❌ Add imports or exports
❌ Change the component function name
❌ Add comments to the code

## OUTPUT FORMAT

Return ONLY valid JSON (no markdown code blocks, no explanation):

{
  "refinedCode": "function ComponentName() { return ( <section>...</section> ) }",
  "changes": ["Added alt text to logo image", "Added focus:ring to CTA button", "Fixed missing key in features map"]
}

If code is already good:

{
  "refinedCode": "the original code unchanged",
  "changes": []
}

Be surgical. Minimal changes. Maximum impact.`

// User-directed refinement prompt - when user asks for specific changes
const USER_REFINE_SYSTEM_PROMPT = `You are a precise code modifier. The user has already generated React + Tailwind code and wants specific changes.

## YOUR TASK

Apply the user's requested changes to the code. Be precise and surgical.

## RULES

1. **Apply exactly what the user asks** - no more, no less
2. **Preserve the original structure** - don't rewrite or reorganize unless asked
3. **Keep the code valid** - ensure it still works after changes
4. **Maintain the style** - keep consistent with existing Tailwind patterns

## OUTPUT FORMAT

Return ONLY valid JSON (no markdown code blocks, no explanation):

{
  "refinedCode": "function ComponentName() { return ( <section>...</section> ) }",
  "changes": ["Made buttons larger with py-4 px-8", "Changed primary color to blue-500"]
}

Apply the requested changes precisely. Do not add unrequested improvements.`

export async function POST(request: NextRequest) {
  try {
    const { userId } = await auth()
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Check user tier and Opus usage limits
    const client = await clerkClient()
    const user = await client.users.getUser(userId)
    const accountSub = user.publicMetadata?.accountSubscription as { 
      status?: string
      tier?: 'pro' | 'agency'
    } | undefined
    
    // Only paid users can use Opus refinements
    if (!accountSub || accountSub.status !== 'active') {
      return NextResponse.json({ 
        error: 'Opus refinements require Pro or Agency subscription',
        upgradeRequired: true 
      }, { status: 403 })
    }

    // Check Opus usage for Pro tier (Agency is unlimited)
    if (accountSub.tier === 'pro') {
      const opusUsed = (user.publicMetadata?.opusRefinementsUsed as number) || 0
      const resetDate = user.publicMetadata?.opusRefinementsResetDate as string | undefined
      const today = new Date().toISOString().split('T')[0]
      
      // Check if we need to reset (new month or past reset date)
      const shouldReset = !resetDate || new Date(resetDate) <= new Date(today)
      const currentUsage = shouldReset ? 0 : opusUsed
      
      if (currentUsage >= PRO_OPUS_MONTHLY_LIMIT) {
        return NextResponse.json({ 
          error: `Monthly Opus limit reached (${PRO_OPUS_MONTHLY_LIMIT}/month). Upgrade to Agency for unlimited refinements.`,
          limitReached: true,
          used: currentUsage,
          limit: PRO_OPUS_MONTHLY_LIMIT
        }, { status: 429 })
      }
    }

    const body = await request.json()
    const { sectionId, code, sectionType, sectionName, userPrompt, refineRequest } = body

    if (!sectionId || !code) {
      return NextResponse.json(
        { error: 'Missing required fields: sectionId, code' },
        { status: 400 }
      )
    }

    // Determine if this is a user-directed refinement or auto-polish
    const isUserDirected = !!refineRequest
    
    // Build the appropriate prompt
    const userMessage = isUserDirected
      ? `Section: ${sectionName || sectionType || 'Unknown'}

CURRENT CODE:
${code}

USER'S REFINEMENT REQUEST:
"${refineRequest}"

Apply these specific changes to the code.`
      : `Section: ${sectionName || sectionType || 'Unknown'}
User's original request: "${userPrompt || 'Not provided'}"

Refine this code:

${code}`

    // Call Opus 4.5 for refinement
    const response = await anthropic.messages.create({
      model: 'claude-opus-4-20250514',
      max_tokens: 8192,
      messages: [
        {
          role: 'user',
          content: userMessage,
        },
      ],
      system: isUserDirected ? USER_REFINE_SYSTEM_PROMPT : REFINER_SYSTEM_PROMPT,
    })

    // Extract the response
    const responseText = response.content
      .filter(block => block.type === 'text')
      .map(block => block.type === 'text' ? block.text : '')
      .join('')
      .trim()

    // Parse JSON response
    let refinedCode = code
    let changes: string[] = []
    let wasRefined = false

    try {
      // Clean any markdown code blocks
      const cleanedResponse = responseText
        .replace(/^```(?:json)?\n?/gm, '')
        .replace(/\n?```$/gm, '')
        .trim()

      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/)
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0])
        refinedCode = parsed.refinedCode || code
        changes = parsed.changes || []
        wasRefined = changes.length > 0
      }
    } catch (parseError) {
      console.error('[refine-section] Failed to parse response:', parseError)
      console.error('[refine-section] Raw response:', responseText.slice(0, 500))
      // Fall back to original code
      refinedCode = code
      changes = []
      wasRefined = false
    }

    // Increment Opus usage for Pro tier after successful refinement
    if (accountSub.tier === 'pro' && wasRefined) {
      try {
        const currentUsed = (user.publicMetadata?.opusRefinementsUsed as number) || 0
        const resetDate = user.publicMetadata?.opusRefinementsResetDate as string | undefined
        const today = new Date()
        
        // Calculate next month's reset date if needed
        let newResetDate = resetDate
        if (!resetDate || new Date(resetDate) <= today) {
          // Set reset to first of next month
          const nextMonth = new Date(today.getFullYear(), today.getMonth() + 1, 1)
          newResetDate = nextMonth.toISOString().split('T')[0]
        }
        
        const shouldReset = !resetDate || new Date(resetDate) <= today
        const newUsed = shouldReset ? 1 : currentUsed + 1
        
        await client.users.updateUser(userId, {
          publicMetadata: {
            ...user.publicMetadata,
            opusRefinementsUsed: newUsed,
            opusRefinementsResetDate: newResetDate,
          }
        })
      } catch (updateError) {
        console.error('[refine-section] Failed to update Opus usage:', updateError)
        // Don't fail the request, just log
      }
    }

    return NextResponse.json({
      refined: wasRefined,
      code: refinedCode,
      changes,
      model: 'opus-4.5',
    })

  } catch (error) {
    console.error('Error refining section:', error)
    return NextResponse.json({ error: 'Failed to refine section' }, { status: 500 })
  }
}