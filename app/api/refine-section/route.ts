import { NextRequest, NextResponse } from 'next/server'
import { auth, clerkClient, currentUser } from '@clerk/nextjs/server'
import { getProjectById, getSectionById, getOrCreateUser, updateSectionRefinement, getSectionsByProjectId } from '@/lib/db'

// =============================================================================
// CLAUDE 3.5 SONNET - THE ARCHITECT (REFINER MODE)
// "The Polisher"
// Auto-polishes code after Genesis builds
// Fixes issues WITHOUT adding features
// Pro tier: 30 refinements/month (configurable), Agency tier: unlimited
// =============================================================================

const FREE_TOTAL_CREDITS = parseInt(process.env.FREE_TOTAL_CREDITS || '9', 10)
const LITE_ARCHITECT_LIMIT = 5 // Lite tier gets 5 refinements/month

const REFINER_SYSTEM_PROMPT = `You are "The Architect" in Refinement Mode.
Your task is to polish React + Tailwind code generated by the Genesis Engine.
You are surgical, precise, and aesthetic-obsessed.

## WHAT TO FIX

1. **Accessibility**
   - Missing alt text on images → add descriptive alt
   - Missing ARIA labels on buttons/links → add aria-label
   - Missing focus states → add focus:ring-2 focus:ring-emerald-500
   - Non-semantic HTML → change div to nav, section, article, etc.
   - Poor heading hierarchy → fix h1/h2/h3 order

2. **Performance**
   - Animations not using transform/opacity → convert to GPU-accelerated
   - Inline functions in JSX → note but don't refactor (minimal changes)

3. **Code Quality**
   - Missing key props in .map() → add unique keys
   - Inconsistent Tailwind class order → organize: layout, spacing, sizing, colors, effects
   - Hardcoded colors → use Tailwind scale (zinc-500 not #71717a)

4. **Interactive States**
   - Buttons missing hover → add hover:bg-*, hover:scale-*
   - Links missing hover → add hover:text-*, hover:underline
   - Missing transitions → add transition-all duration-200

5. **Visual Analysis (The Retina)**
   - If a screenshot is provided, analyze it for layout issues, contrast problems, or visual bugs.
   - Fix alignment issues visible in the render.
   - Ensure text contrast meets accessibility standards.

## WHAT NOT TO DO

❌ Add new features or content
❌ Change the design intent or layout
❌ Remove or add sections
❌ Rewrite the component from scratch
❌ Add imports or exports
❌ Change the component function name
❌ Add comments to the code

## OUTPUT FORMAT

Return ONLY valid JSON (no markdown code blocks, no explanation):

{
  "refinedCode": "function ComponentName() { return ( <section>...</section> ) }",
  "changes": ["Added alt text to logo image", "Added focus:ring to CTA button", "Fixed missing key in features map"]
}

If code is already good:

{
  "refinedCode": "the original code unchanged",
  "changes": []
}

Be surgical. Minimal changes. Maximum impact.`

// User-directed refinement prompt - when user asks for specific changes
const USER_REFINE_SYSTEM_PROMPT = `You are a precise code modifier. The user has already generated React + Tailwind code and wants specific changes.

## YOUR TASK

Apply the user's requested changes to the code. Be precise and surgical.

## RULES

1. **Apply exactly what the user asks** - no more, no less
2. **Preserve the original structure** - don't rewrite or reorganize unless asked
3. **Keep the code valid** - ensure it still works after changes
4. **Maintain the style** - keep consistent with existing Tailwind patterns

## OUTPUT FORMAT

Return ONLY valid JSON (no markdown code blocks, no explanation):

{
  "refinedCode": "function ComponentName() { return ( <section>...</section> ) }",
  "changes": ["Made buttons larger with py-4 px-8", "Changed primary color to emerald-500"]
}
`

export async function POST(request: NextRequest) {
  try {
    const { userId } = await auth()
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Parse body early to check for self-healing (which is free)
    const body = await request.json()
    const { sectionId, projectId, code, sectionType, sectionName, userPrompt, refineRequest, screenshot } = body

    // Self-healing check: If the request is to fix a runtime error, it's free.
    // "FIX RUNTIME ERROR" is the prefix used in SectionBuilder.tsx
    const isSelfHealing = refineRequest && refineRequest.startsWith('FIX RUNTIME ERROR')

    // Check user tier and Architect usage limits
    const client = await clerkClient()
    const user = await client.users.getUser(userId)
    const accountSub = user.publicMetadata?.accountSubscription as { 
      status?: string
      tier?: 'architect' | 'visionary' | 'singularity'
    } | undefined
    
    const freeCreditsUsed = (user.publicMetadata?.freeCreditsUsed as number) || 0
    const hasActiveSub = accountSub?.status === 'active'
    const architectUsed = (user.publicMetadata?.architectRefinementsUsed as number) || 0

    // Free users: allow up to FREE_REFINE_LIMIT (1), then block
    const FREE_REFINE_LIMIT = 1
    
    if (!isSelfHealing && !hasActiveSub && architectUsed >= FREE_REFINE_LIMIT) {
      return NextResponse.json({
        error: 'Free refinement limit reached. Upgrade to Architect for unlimited polish.',
        limitReached: true,
        used: architectUsed,
        limit: FREE_REFINE_LIMIT,
      }, { status: 429 })
    }

    // Check Architect usage for paid tiers (Singularity is unlimited)
    // Skip check if self-healing
    if (!isSelfHealing && hasActiveSub && accountSub?.tier && accountSub.tier !== 'singularity') {
      const resetDate = user.publicMetadata?.architectRefinementsResetDate as string | undefined
      const today = new Date().toISOString().split('T')[0]
      
      // Check if we need to reset (new month or past reset date)
      const shouldReset = !resetDate || new Date(resetDate) <= new Date(today)
      const currentUsage = shouldReset ? 0 : architectUsed
      
      const limit = accountSub.tier === 'architect'
        ? LITE_ARCHITECT_LIMIT
        : parseInt(process.env.PRO_ARCHITECT_MONTHLY_LIMIT || '30', 10)

      if (currentUsage >= limit) {
        return NextResponse.json({ 
          error: `Monthly refinement limit reached (${limit}/month). ${accountSub?.tier === 'architect' ? 'Upgrade to Visionary for 30/month.' : 'Upgrade to Singularity for unlimited.'}`,
          limitReached: true,
          used: currentUsage,
          limit: limit
        }, { status: 429 })
      }
    }

    const clerkUser = await currentUser()
    const email = clerkUser?.emailAddresses?.[0]?.emailAddress
    const dbUser = await getOrCreateUser(userId, email)
    if (!dbUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 })
    }

    if (!sectionId || !code) {
      return NextResponse.json(
        { error: 'Missing required fields: sectionId, code' },
        { status: 400 }
      )
    }

    // Verify ownership: section -> project -> user (using internal ID)
    let section = await getSectionById(sectionId)
    
    // Fallback: Try to find by projectId + sectionType if sectionId lookup failed
    if (!section && projectId && sectionType) {
      const projectSections = await getSectionsByProjectId(projectId)
      section = projectSections.find(s => s.section_id === sectionType) || null
    }

    console.log('[Refine] Found section:', section ? section.id : 'null')
    if (!section) {
      return NextResponse.json({ error: `Section not found for ID: ${sectionId}` }, { status: 404 })
    }
    const project = await getProjectById(section.project_id)
    if (!project) {
      return NextResponse.json({ error: 'Project not found' }, { status: 404 })
    }
    if (project.user_id !== dbUser.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 403 })
    }

    // Determine if this is a user-directed refinement or auto-polish
    const isUserDirected = !!refineRequest
    
    // Build the appropriate prompt
    const userMessage = isUserDirected
      ? `Section: ${sectionName || sectionType || 'Unknown'}

CURRENT CODE:
${code}

USER'S REFINEMENT REQUEST:
"${refineRequest}"

Apply these specific changes to the code.`
      : `Section: ${sectionName || sectionType || 'Unknown'}
User's original request: "${userPrompt || 'Not provided'}"

Refine this code:

${code}`

    // Prepare messages for Claude
    const messages: any[] = [
      { role: 'user', content: [] }
    ]

    // Add text content
    messages[0].content.push({
      type: 'text',
      text: userMessage
    })

    // Add visual context if screenshot is provided (The Retina)
    if (screenshot) {
      // Remove data URL prefix if present to get raw base64
      const base64Data = screenshot.replace(/^data:image\/\w+;base64,/, "")
      
      messages[0].content.push({
        type: 'text',
        text: "I have attached a screenshot of the currently rendered component. Use this visual data to identify layout issues, contrast problems, or visual bugs that might not be obvious in the code alone. If the visual output contradicts the code's intent, prioritize fixing the code to match the visual goal."
      })
      
      messages[0].content.push({
        type: 'image',
        source: {
          type: 'base64',
          media_type: 'image/png',
          data: base64Data
        }
      })
    }

    // Call Claude 3.5 Sonnet for refinement
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': process.env.ANTHROPIC_API_KEY || '',
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: 8192,
        system: isUserDirected ? USER_REFINE_SYSTEM_PROMPT : REFINER_SYSTEM_PROMPT,
        messages: messages
      })
    })

    if (!response.ok) {
      const error = await response.json()
      console.error('Anthropic API error:', error)
      return NextResponse.json({ error: 'Refinement failed' }, { status: 500 })
    }

    const data = await response.json()
    const responseText = data.content[0]?.text || ''
    console.log('[refine-section] Raw response:', responseText.slice(0, 500))

    // Parse JSON response
    let refinedCode = code
    let changes: string[] = []
    let wasRefined = false

    try {
      const cleanedResponse = responseText
        .replace(/^```(?:json)?\n?/gm, '')
        .replace(/\n?```$/gm, '')
        .trim()

      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/)
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0])
        refinedCode = parsed.refinedCode || code
        changes = parsed.changes || []
        wasRefined = changes.length > 0
      }
    } catch (parseError) {
      console.error('[refine-section] Failed to parse response:', parseError)
      
      // Fallback: Extract code block directly
      if (!wasRefined) {
         const codeMatch = responseText.match(/```(?:tsx|jsx|javascript|typescript)?\n([\s\S]*?)```/)
         if (codeMatch) {
            refinedCode = codeMatch[1]
            changes = ["Extracted code from raw output"]
            wasRefined = true
         }
      }
    }

    // Increment Refinement usage for paid tiers after successful refinement
    // Skip if self-healing (free)
    if (!isSelfHealing && hasActiveSub && accountSub?.tier && accountSub.tier !== 'singularity' && wasRefined) {
      try {
        const currentUsed = (user.publicMetadata?.architectRefinementsUsed as number) || 0
        const resetDate = user.publicMetadata?.architectRefinementsResetDate as string | undefined
        const today = new Date()
        
        // Calculate next month's reset date if needed
        let newResetDate = resetDate
        if (!resetDate || new Date(resetDate) <= today) {
          // Set reset to first of next month
          const nextMonth = new Date(today.getFullYear(), today.getMonth() + 1, 1)
          newResetDate = nextMonth.toISOString().split('T')[0]
        }
        
        const shouldReset = !resetDate || new Date(resetDate) <= today
        const newUsed = shouldReset ? 1 : currentUsed + 1
        
        await client.users.updateUser(userId, {
          publicMetadata: {
            ...user.publicMetadata,
            architectRefinementsUsed: newUsed,
            architectRefinementsResetDate: newResetDate,
          }
        })
      } catch (updateError) {
        console.error('[refine-section] Failed to update Refinement usage:', updateError)
        // Don't fail the request, just log
      }
    }

    // Track free credit usage for non-paid users
    if (!isSelfHealing && !hasActiveSub && wasRefined) {
      try {
        await client.users.updateUser(userId, {
          publicMetadata: {
            ...user.publicMetadata,
            freeCreditsUsed: freeCreditsUsed + 1,
          },
        })
      } catch (updateError) {
        console.error('[refine-section] Failed to update free credit usage:', updateError)
      }
    }

    // SAVE TO DATABASE - persist the refined code
    if (wasRefined) {
      await updateSectionRefinement(sectionId, true, refinedCode, changes)
    }

    return NextResponse.json({
      refined: wasRefined,
      code: refinedCode,
      changes,
      model: 'claude-3.5-sonnet',
    })

  } catch (error) {
    console.error('Error refining section:', error)
    return NextResponse.json({ error: 'Failed to refine section' }, { status: 500 })
  }
}
