import { NextRequest, NextResponse } from 'next/server'
import { auth, clerkClient, currentUser } from '@clerk/nextjs/server'
import { GoogleGenAI } from '@google/genai'
import { PRO_ARCHITECT_MONTHLY_LIMIT } from '@/types/subscriptions'
import { getProjectById, getSectionById, getOrCreateUser, updateSectionRefinement, getSectionsByProjectId } from '@/lib/db'

// =============================================================================
// GEMINI 2.0 FLASH - THE ARCHITECT (REFINER MODE)
// "The Polisher"
// Auto-polishes code after Genesis builds
// Fixes issues WITHOUT adding features
// Pro tier: 30 refinements/month (configurable), Agency tier: unlimited
// =============================================================================

const geminiApiKey = process.env.GEMINI_API_KEY
const genai = geminiApiKey ? new GoogleGenAI({ apiKey: geminiApiKey }) : null

const REFINER_SYSTEM_PROMPT = `You are "The Architect" in Refinement Mode.
Your task is to polish React + Tailwind code generated by the Genesis Engine.
You are surgical, precise, and aesthetic-obsessed.

## WHAT TO FIX

1. **Accessibility**
   - Missing alt text on images → add descriptive alt
   - Missing ARIA labels on buttons/links → add aria-label
   - Missing focus states → add focus:ring-2 focus:ring-emerald-500
   - Non-semantic HTML → change div to nav, section, article, etc.
   - Poor heading hierarchy → fix h1/h2/h3 order

2. **Performance**
   - Animations not using transform/opacity → convert to GPU-accelerated
   - Inline functions in JSX → note but don't refactor (minimal changes)

3. **Code Quality**
   - Missing key props in .map() → add unique keys
   - Inconsistent Tailwind class order → organize: layout, spacing, sizing, colors, effects
   - Hardcoded colors → use Tailwind scale (zinc-500 not #71717a)

4. **Interactive States**
   - Buttons missing hover → add hover:bg-*, hover:scale-*
   - Links missing hover → add hover:text-*, hover:underline
   - Missing transitions → add transition-all duration-200

5. **Visual Analysis (The Retina)**
   - If a screenshot is provided, analyze it for layout issues, contrast problems, or visual bugs.
   - Fix alignment issues visible in the render.
   - Ensure text contrast meets accessibility standards.

## WHAT NOT TO DO

❌ Add new features or content
❌ Change the design intent or layout
❌ Remove or add sections
❌ Rewrite the component from scratch
❌ Add imports or exports
❌ Change the component function name
❌ Add comments to the code

## OUTPUT FORMAT

Return ONLY valid JSON (no markdown code blocks, no explanation):

{
  "refinedCode": "function ComponentName() { return ( <section>...</section> ) }",
  "changes": ["Added alt text to logo image", "Added focus:ring to CTA button", "Fixed missing key in features map"]
}

If code is already good:

{
  "refinedCode": "the original code unchanged",
  "changes": []
}

Be surgical. Minimal changes. Maximum impact.`

// User-directed refinement prompt - when user asks for specific changes
const USER_REFINE_SYSTEM_PROMPT = `You are a precise code modifier. The user has already generated React + Tailwind code and wants specific changes.

## YOUR TASK

Apply the user's requested changes to the code. Be precise and surgical.

## RULES

1. **Apply exactly what the user asks** - no more, no less
2. **Preserve the original structure** - don't rewrite or reorganize unless asked
3. **Keep the code valid** - ensure it still works after changes
4. **Maintain the style** - keep consistent with existing Tailwind patterns

## OUTPUT FORMAT

Return ONLY valid JSON (no markdown code blocks, no explanation):

{
  "refinedCode": "function ComponentName() { return ( <section>...</section> ) }",
  "changes": ["Made buttons larger with py-4 px-8", "Changed primary color to emerald-500"]
}

Apply the requested changes precisely. Do not add unrequested improvements.`

export async function POST(request: NextRequest) {
  try {
    const { userId } = await auth()
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Parse body early to check for self-healing (which is free)
    const body = await request.json()
    const { sectionId, projectId, code, sectionType, sectionName, userPrompt, refineRequest, screenshot } = body

    // Self-healing check: If the request is to fix a runtime error, it's free.
    // "FIX RUNTIME ERROR" is the prefix used in SectionBuilder.tsx
    const isSelfHealing = refineRequest && refineRequest.startsWith('FIX RUNTIME ERROR')

    // Check user tier and Architect usage limits
    const client = await clerkClient()
    const user = await client.users.getUser(userId)
    const accountSub = user.publicMetadata?.accountSubscription as { 
      status?: string
      tier?: 'pro' | 'agency'
    } | undefined
    
    // Only paid users can use Architect refinements (unless self-healing)
    if (!isSelfHealing && (!accountSub || accountSub.status !== 'active')) {
      return NextResponse.json({ 
        error: 'Architect refinements require Pro or Agency subscription',
        upgradeRequired: true 
      }, { status: 403 })
    }

    // Check Architect usage for Pro tier (Agency is unlimited)
    // Skip check if self-healing
    if (!isSelfHealing && accountSub?.tier === 'pro') {
      const architectUsed = (user.publicMetadata?.architectRefinementsUsed as number) || 0
      const resetDate = user.publicMetadata?.architectRefinementsResetDate as string | undefined
      const today = new Date().toISOString().split('T')[0]
      
      // Check if we need to reset (new month or past reset date)
      const shouldReset = !resetDate || new Date(resetDate) <= new Date(today)
      const currentUsage = shouldReset ? 0 : architectUsed
      
      if (currentUsage >= PRO_ARCHITECT_MONTHLY_LIMIT) {
        return NextResponse.json({ 
          error: `Monthly Architect limit reached (${PRO_ARCHITECT_MONTHLY_LIMIT}/month). Upgrade to Agency for unlimited refinements.`,
          limitReached: true,
          used: currentUsage,
          limit: PRO_ARCHITECT_MONTHLY_LIMIT
        }, { status: 429 })
      }
    }

    const clerkUser = await currentUser()
    const email = clerkUser?.emailAddresses?.[0]?.emailAddress
    const dbUser = await getOrCreateUser(userId, email)
    if (!dbUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 })
    }

    if (!sectionId || !code) {
      return NextResponse.json(
        { error: 'Missing required fields: sectionId, code' },
        { status: 400 }
      )
    }

    // Verify ownership: section -> project -> user (using internal ID)
    console.log('[Refine] Lookup section:', sectionId)
    let section = await getSectionById(sectionId)
    
    // Fallback: Try to find by projectId + sectionType if sectionId lookup failed
    if (!section && projectId && sectionType) {
      console.log(`[Refine] Fallback lookup: projectId=${projectId}, sectionType=${sectionType}`)
      const projectSections = await getSectionsByProjectId(projectId)
      section = projectSections.find(s => s.section_id === sectionType) || null
      if (section) {
        console.log('[Refine] Found section via fallback:', section.id)
      }
    }

    console.log('[Refine] Found section:', section ? section.id : 'null')
    if (!section) {
      return NextResponse.json({ error: `Section not found for ID: ${sectionId}` }, { status: 404 })
    }
    const project = await getProjectById(section.project_id)
    if (!project) {
      return NextResponse.json({ error: 'Project not found' }, { status: 404 })
    }
    if (project.user_id !== dbUser.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 403 })
    }

    // Determine if this is a user-directed refinement or auto-polish
    const isUserDirected = !!refineRequest
    
    // Build the appropriate prompt
    const userMessage = isUserDirected
      ? `Section: ${sectionName || sectionType || 'Unknown'}

CURRENT CODE:
${code}

USER'S REFINEMENT REQUEST:
"${refineRequest}"

Apply these specific changes to the code.`
      : `Section: ${sectionName || sectionType || 'Unknown'}
User's original request: "${userPrompt || 'Not provided'}"

Refine this code:

${code}`

    // Prepare content parts for Gemini
    const parts: any[] = [
      { text: isUserDirected ? USER_REFINE_SYSTEM_PROMPT : REFINER_SYSTEM_PROMPT },
      { text: userMessage }
    ]

    // Add visual context if screenshot is provided (The Retina)
    if (screenshot) {
      // Remove data URL prefix if present to get raw base64
      const base64Data = screenshot.replace(/^data:image\/\w+;base64,/, "")
      
      parts.push({
        text: "I have attached a screenshot of the currently rendered component. Use this visual data to identify layout issues, contrast problems, or visual bugs that might not be obvious in the code alone. If the visual output contradicts the code's intent, prioritize fixing the code to match the visual goal."
      })
      
      parts.push({
        inlineData: {
          mimeType: "image/png",
          data: base64Data
        }
      })
    }

    // Call Gemini 2.0 Flash for refinement
    if (!genai) {
      return NextResponse.json({ error: 'Gemini API key not configured' }, { status: 500 })
    }

    const response = await genai.models.generateContent({
      model: 'gemini-2.0-flash-001',
      config: {
        responseMimeType: 'application/json',
      },
      contents: [
        {
          role: 'user',
          parts: parts
        }
      ]
    })

    // Extract the response
    const responseText = response.text || ''

    // Parse JSON response
    let refinedCode = code
    let changes: string[] = []
    let wasRefined = false

    try {
      const parsed = JSON.parse(responseText)
      refinedCode = parsed.refinedCode || code
      changes = parsed.changes || []
      wasRefined = changes.length > 0
    } catch (parseError) {
      console.error('[refine-section] Failed to parse response:', parseError)
      console.error('[refine-section] Raw response:', responseText.slice(0, 500))
      // Fall back to original code
      refinedCode = code
      changes = []
      wasRefined = false
    }

    // Increment Refinement usage for Pro tier after successful refinement
    // Skip if self-healing (free)
    if (!isSelfHealing && accountSub?.tier === 'pro' && wasRefined) {
      try {
        const currentUsed = (user.publicMetadata?.architectRefinementsUsed as number) || 0
        const resetDate = user.publicMetadata?.architectRefinementsResetDate as string | undefined
        const today = new Date()
        
        // Calculate next month's reset date if needed
        let newResetDate = resetDate
        if (!resetDate || new Date(resetDate) <= today) {
          // Set reset to first of next month
          const nextMonth = new Date(today.getFullYear(), today.getMonth() + 1, 1)
          newResetDate = nextMonth.toISOString().split('T')[0]
        }
        
        const shouldReset = !resetDate || new Date(resetDate) <= today
        const newUsed = shouldReset ? 1 : currentUsed + 1
        
        await client.users.updateUser(userId, {
          publicMetadata: {
            ...user.publicMetadata,
            architectRefinementsUsed: newUsed,
            architectRefinementsResetDate: newResetDate,
          }
        })
      } catch (updateError) {
        console.error('[refine-section] Failed to update Refinement usage:', updateError)
        // Don't fail the request, just log
      }
    }

    // SAVE TO DATABASE - persist the refined code
    if (wasRefined) {
      await updateSectionRefinement(sectionId, true, refinedCode, changes)
    }

    return NextResponse.json({
      refined: wasRefined,
      code: refinedCode,
      changes,
      model: 'gemini-2.0-flash',
    })

  } catch (error) {
    console.error('Error refining section:', error)
    return NextResponse.json({ error: 'Failed to refine section' }, { status: 500 })
  }
}